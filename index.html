import React, { useRef, useState, useEffect, useCallback } from 'react';
import { Pencil, Eraser, Trash2, Download, Undo, Minus, Plus, Palette, X } from 'lucide-react';

export default function DrawingApp() {
  const canvasRef = useRef(null);
  const contextRef = useRef(null);
  const containerRef = useRef(null);
  
  // State management
  const [isDrawing, setIsDrawing] = useState(false);
  const [color, setColor] = useState('#000000');
  const [lineWidth, setLineWidth] = useState(5);
  const [tool, setTool] = useState('pen'); // 'pen' or 'eraser'
  const [history, setHistory] = useState([]);
  const [historyStep, setHistoryStep] = useState(-1);
  const [showColorPicker, setShowColorPicker] = useState(false);

  // Preset colors
  const presetColors = [
    '#000000', '#FF0000', '#0000FF', '#008000', '#FFFF00', 
    '#FFA500', '#800080', '#FFC0CB', '#A52A2A', '#808080'
  ];

  // Initialize Canvas
  useEffect(() => {
    const canvas = canvasRef.current;
    const container = containerRef.current;
    
    const updateCanvasSize = () => {
      // Save current content before resizing
      let tempImage = null;
      if (canvas.width > 0 && canvas.height > 0) {
        tempImage = canvas.toDataURL();
      }

      const rect = container.getBoundingClientRect();
      // Handle High DPI displays
      const dpr = window.devicePixelRatio || 1;
      
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      canvas.style.width = `${rect.width}px`;
      canvas.style.height = `${rect.height}px`;

      const ctx = canvas.getContext('2d');
      ctx.scale(dpr, dpr);
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.strokeStyle = color;
      ctx.lineWidth = lineWidth;
      contextRef.current = ctx;

      // Restore content if it existed (simple resize handling)
      if (tempImage) {
        const img = new Image();
        img.src = tempImage;
        img.onload = () => {
          ctx.drawImage(img, 0, 0, rect.width, rect.height);
        };
      } else {
        // Initial white background
        ctx.fillStyle = "white";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        saveHistory(); // Save initial blank state
      }
    };

    updateCanvasSize();
    window.addEventListener('resize', updateCanvasSize);

    return () => {
      window.removeEventListener('resize', updateCanvasSize);
    };
  }, []);

  // Update context properties when state changes
  useEffect(() => {
    if (contextRef.current) {
      contextRef.current.strokeStyle = tool === 'eraser' ? '#FFFFFF' : color;
      contextRef.current.lineWidth = lineWidth;
    }
  }, [color, lineWidth, tool]);

  // History Management
  const saveHistory = useCallback(() => {
    if (!canvasRef.current) return;
    
    // Create a limit for history to prevent memory issues
    const newHistory = history.slice(0, historyStep + 1);
    const imageData = canvasRef.current.toDataURL();
    
    // Don't save duplicate states
    if (newHistory.length > 0 && newHistory[newHistory.length - 1] === imageData) {
      return;
    }

    const updatedHistory = [...newHistory, imageData];
    // Keep max 20 steps
    if (updatedHistory.length > 20) updatedHistory.shift();
    
    setHistory(updatedHistory);
    setHistoryStep(updatedHistory.length - 1);
  }, [history, historyStep]);

  const undo = () => {
    if (historyStep > 0) {
      const newStep = historyStep - 1;
      const imageData = history[newStep];
      restoreCanvasState(imageData);
      setHistoryStep(newStep);
    }
  };

  const restoreCanvasState = (dataUrl) => {
    const canvas = canvasRef.current;
    const ctx = contextRef.current;
    const img = new Image();
    img.src = dataUrl;
    img.onload = () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // Determine logical width/height from CSS style to draw correctly scaled
      const rect = canvas.getBoundingClientRect();
      ctx.drawImage(img, 0, 0, rect.width, rect.height);
    };
  };

  // Drawing Handlers
  const getCoordinates = (event) => {
    const canvas = canvasRef.current;
    const rect = canvas.getBoundingClientRect();
    
    let clientX, clientY;
    
    if (event.touches && event.touches.length > 0) {
      clientX = event.touches[0].clientX;
      clientY = event.touches[0].clientY;
    } else {
      clientX = event.clientX;
      clientY = event.clientY;
    }
    
    return {
      x: clientX - rect.left,
      y: clientY - rect.top
    };
  };

  const startDrawing = (event) => {
    // Prevent default touch actions (scrolling)
    if (event.type === 'touchstart') {
      // We don't prevent default here to allow UI interaction, 
      // but we handle touch-action via CSS
    }

    const { x, y } = getCoordinates(event);
    contextRef.current.beginPath();
    contextRef.current.moveTo(x, y);
    setIsDrawing(true);
  };

  const draw = (event) => {
    if (!isDrawing) return;
    
    // Prevent scrolling when drawing on touch devices
    if (event.type === 'touchmove') {
      event.preventDefault(); 
    }

    const { x, y } = getCoordinates(event);
    contextRef.current.lineTo(x, y);
    contextRef.current.stroke();
  };

  const stopDrawing = () => {
    if (isDrawing) {
      contextRef.current.closePath();
      setIsDrawing(false);
      saveHistory();
    }
  };

  // Tool Actions
  const clearCanvas = () => {
    const canvas = canvasRef.current;
    const ctx = contextRef.current;
    
    // Fill with white instead of transparent clearRect
    ctx.fillStyle = "white";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    saveHistory();
  };

  const downloadImage = () => {
    const canvas = canvasRef.current;
    const link = document.createElement('a');
    link.download = `drawing_${new Date().getTime()}.png`;
    link.href = canvas.toDataURL();
    link.click();
  };

  return (
    <div className="flex flex-col h-screen bg-gray-100 font-sans overflow-hidden select-none">
      {/* Header / Toolbar */}
      <header className="bg-white shadow-sm px-4 py-2 flex items-center justify-between z-10 shrink-0 h-16">
        <div className="flex items-center gap-2">
          <div className="p-2 bg-indigo-600 rounded-lg text-white">
            <Palette size={20} />
          </div>
          <h1 className="text-lg font-bold text-gray-800 hidden sm:block">お絵描きアプリ</h1>
        </div>

        <div className="flex items-center gap-2 sm:gap-4">
          {/* Undo Button */}
          <button 
            onClick={undo}
            disabled={historyStep <= 0}
            className={`p-2 rounded-full transition-colors ${
              historyStep <= 0 
                ? 'text-gray-300 cursor-not-allowed' 
                : 'text-gray-600 hover:bg-gray-100 active:scale-95'
            }`}
            title="元に戻す"
          >
            <Undo size={20} />
          </button>

          <div className="h-6 w-px bg-gray-200 mx-1" />

          {/* Tools */}
          <div className="flex bg-gray-100 p-1 rounded-lg">
            <button
              onClick={() => setTool('pen')}
              className={`p-2 rounded-md transition-all ${
                tool === 'pen' ? 'bg-white shadow text-indigo-600' : 'text-gray-500 hover:text-gray-700'
              }`}
              title="ペン"
            >
              <Pencil size={20} />
            </button>
            <button
              onClick={() => setTool('eraser')}
              className={`p-2 rounded-md transition-all ${
                tool === 'eraser' ? 'bg-white shadow text-indigo-600' : 'text-gray-500 hover:text-gray-700'
              }`}
              title="消しゴム"
            >
              <Eraser size={20} />
            </button>
          </div>
        </div>

        <div className="flex items-center gap-2">
          <button 
            onClick={clearCanvas}
            className="p-2 text-red-500 hover:bg-red-50 rounded-lg transition-colors"
            title="すべて消去"
          >
            <Trash2 size={20} />
          </button>
          <button 
            onClick={downloadImage}
            className="flex items-center gap-2 px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors shadow-sm active:scale-95"
            title="保存"
          >
            <Download size={18} />
            <span className="hidden sm:inline text-sm font-medium">保存</span>
          </button>
        </div>
      </header>

      {/* Main Canvas Area */}
      <div 
        ref={containerRef}
        className="flex-1 relative cursor-crosshair bg-gray-200 overflow-hidden"
      >
        <canvas
          ref={canvasRef}
          onMouseDown={startDrawing}
          onMouseMove={draw}
          onMouseUp={stopDrawing}
          onMouseLeave={stopDrawing}
          onTouchStart={startDrawing}
          onTouchMove={draw}
          onTouchEnd={stopDrawing}
          className="absolute top-0 left-0 touch-none shadow-inner bg-white"
          style={{ touchAction: 'none' }}
        />
        
        {/* Floating Controls (Bottom) */}
        <div className="absolute bottom-6 left-1/2 transform -translate-x-1/2 bg-white rounded-2xl shadow-xl border border-gray-100 p-3 flex flex-col items-center gap-3 w-[90%] max-w-md transition-all">
          
          {/* Size Slider */}
          <div className="w-full flex items-center gap-3 px-2">
            <span className="text-xs text-gray-400 font-medium w-8">太さ</span>
            <button 
              onClick={() => setLineWidth(Math.max(1, lineWidth - 2))}
              className="p-1 text-gray-400 hover:text-indigo-600"
            >
              <Minus size={14} />
            </button>
            <input
              type="range"
              min="1"
              max="50"
              value={lineWidth}
              onChange={(e) => setLineWidth(parseInt(e.target.value))}
              className="flex-1 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-indigo-600"
            />
            <button 
              onClick={() => setLineWidth(Math.min(50, lineWidth + 2))}
              className="p-1 text-gray-400 hover:text-indigo-600"
            >
              <Plus size={14} />
            </button>
            <div 
              className="w-6 h-6 rounded-full bg-gray-800 flex items-center justify-center text-[10px] text-white font-bold"
              style={{ backgroundColor: tool === 'eraser' ? '#ccc' : color }}
            >
              {lineWidth}
            </div>
          </div>

          <div className="h-px w-full bg-gray-100" />

          {/* Color Picker */}
          <div className="flex items-center justify-between w-full overflow-x-auto gap-2 px-1 pb-1 no-scrollbar">
            {presetColors.map((c) => (
              <button
                key={c}
                onClick={() => {
                  setColor(c);
                  setTool('pen');
                }}
                className={`w-8 h-8 rounded-full border-2 flex-shrink-0 transition-transform ${
                  color === c && tool === 'pen' ? 'border-indigo-500 scale-110' : 'border-transparent hover:scale-110'
                }`}
                style={{ backgroundColor: c }}
                aria-label={c}
              />
            ))}
            
            <div className="w-px h-6 bg-gray-200 mx-1 flex-shrink-0" />
            
            <button
              onClick={() => setShowColorPicker(!showColorPicker)}
              className={`w-8 h-8 rounded-full border-2 flex items-center justify-center flex-shrink-0 ${
                 showColorPicker ? 'border-indigo-500' : 'border-gray-200'
              }`}
              style={{ 
                background: 'conic-gradient(red, yellow, lime, aqua, blue, magenta, red)' 
              }}
            >
              {showColorPicker && <div className="w-2 h-2 bg-white rounded-full shadow" />}
            </button>
          </div>

          {/* Extended Color Picker Popup */}
          {showColorPicker && (
            <div className="absolute bottom-full mb-4 bg-white p-3 rounded-xl shadow-xl border border-gray-100 animate-in fade-in slide-in-from-bottom-4">
              <div className="flex items-center justify-between mb-2">
                <span className="text-xs font-bold text-gray-500">カスタムカラー</span>
                <button onClick={() => setShowColorPicker(false)} className="text-gray-400 hover:text-gray-600">
                  <X size={14} />
                </button>
              </div>
              <input 
                type="color" 
                value={color}
                onChange={(e) => {
                  setColor(e.target.value);
                  setTool('pen');
                }}
                className="w-full h-10 rounded cursor-pointer"
              />
            </div>
          )}
        </div>
      </div>
    </div>
  );
}
